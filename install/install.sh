#!/usr/bin/env bash
set -euo pipefail

INSTALL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${INSTALL_DIR}/.." && pwd)"
CALLICO_DIR="${PROJECT_ROOT}/callico"
ENV_FILE="${INSTALL_DIR}/production.env"
ENV_EXAMPLE="${ENV_FILE}.example"
DEFAULT_DOMAIN="localhost"

is_local_domain() {
  case "$1" in
    localhost|127.0.0.1|0.0.0.0)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

urlencode() {
  python3 -c 'import sys, urllib.parse; print(urllib.parse.quote(sys.argv[1], safe=""))' "$1"
}

create_env_file() {
  if [[ ! -t 0 ]]; then
    return 1
  fi

  if ! command -v python3 >/dev/null 2>&1; then
    echo "python3 is required to generate ${ENV_FILE} automatically." >&2
    return 1
  fi

  local root_domain password confirm scheme instance_url env_content answer
  local flower_domain minio_domain minio_console_domain traefik_domain acme_email
  local postgres_password_urlencoded

  echo "Missing production environment file."
  echo "Let's create ${ENV_FILE}. Press Ctrl+C to abort."

  read -rp "Root domain [${DEFAULT_DOMAIN}]: " root_domain
  root_domain="${root_domain:-${DEFAULT_DOMAIN}}"

  while :; do
    read -rsp "Common password (used for database, admin, Minio) : " password
    echo
    if [[ -z "${password}" ]]; then
      echo "Password cannot be empty."
      continue
    fi
    read -rsp "Confirm password: " confirm
    echo
    if [[ "${password}" != "${confirm}" ]]; then
      echo "Passwords do not match, please try again."
      continue
    fi
    break
  done

  scheme="https"
  if [[ "${root_domain}" =~ ^(localhost|127\.0\.0\.1|0\.0\.0\.0)$ ]]; then
    scheme="http"
  fi

  instance_url="${scheme}://${root_domain}"
  flower_domain="tasks.${root_domain}"
  minio_domain="minio.${root_domain}"
  minio_console_domain="minio-console.${root_domain}"
  traefik_domain="traefik.${root_domain}"

  if [[ "${root_domain}" == "${DEFAULT_DOMAIN}" ]]; then
    acme_email="admin@example.com"
  else
    acme_email="admin@${root_domain}"
  fi

  postgres_password_urlencoded="$(urlencode "${password}")"

  env_content=$(cat <<EOF
# Generated by install/install.sh on $(date)

CALLICO_DOMAIN=${root_domain}

FLOWER_DOMAIN=${flower_domain}
MINIO_DOMAIN=${minio_domain}
MINIO_CONSOLE_DOMAIN=${minio_console_domain}
TRAEFIK_DASHBOARD_DOMAIN=${traefik_domain}

TRAEFIK_HTTP_BIND_ADDRESS=0.0.0.0
TRAEFIK_HTTPS_BIND_ADDRESS=0.0.0.0
TRAEFIK_CONFIG_FILE=../install/traefik/traefik.toml
TRAEFIK_CERTS_DIR=../install/traefik/certs
TRAEFIK_TLS_CONFIG_FILE=../install/traefik/certs/tls.toml
TRAEFIK_TLS_CERT_FILE=
TRAEFIK_TLS_KEY_FILE=
TRAEFIK_ACME_EMAIL=${acme_email}

INSTANCE_URL=${instance_url}
ALLOWED_HOSTS=${root_domain}
CSRF_TRUSTED_ORIGINS=${instance_url}
SIGNUP_ENABLED=false

DJANGO_SUPERUSER_USERNAME=admin
DJANGO_SUPERUSER_EMAIL=admin@${root_domain}
DJANGO_SUPERUSER_PASSWORD=${password}
DJANGO_SUPERUSER_FIRST_NAME=Admin
DJANGO_SUPERUSER_LAST_NAME=User
DJANGO_SUPERUSER_DISPLAY_NAME=Admin User

POSTGRES_USER=callico
POSTGRES_PASSWORD=${password}
POSTGRES_DB=callico
POSTGRES_HOST=postgres
POSTGRES_PORT=5432
DATABASE_URL=postgres://callico:${postgres_password_urlencoded}@postgres:5432/callico

MINIO_ROOT_USER=callico-minio
MINIO_ROOT_PASSWORD=${password}
AWS_ACCESS_KEY_ID=callico-minio
AWS_SECRET_ACCESS_KEY=${password}
STORAGE_BUCKET_NAME=callico
STORAGE_ENDPOINT_URL=${scheme}://${minio_domain}
MINIO_BROWSER_REDIRECT_URL=${scheme}://${minio_console_domain}

REDIS_URL=redis://redis:6379/0
EOF
  )

  echo
  echo "The following configuration will be written to ${ENV_FILE}:"
  echo "----------------------------------------------------------------"
  printf '%s\n' "${env_content}"
  echo "----------------------------------------------------------------"
  read -rp "Write this configuration to ${ENV_FILE}? [Y/n] " answer
  if [[ "${answer}" =~ ^[Nn] ]]; then
    return 1
  fi

  umask 077
  printf '%s\n' "${env_content}" >"${ENV_FILE}"
  echo "Configuration saved to ${ENV_FILE}."
}
COMPOSE_ARGS=(
  --project-name callico-prod
  --project-directory "${CALLICO_DIR}"
  -f "${CALLICO_DIR}/docker-compose.yml"
  --env-file "${ENV_FILE}"
)

if [[ ! -d "${CALLICO_DIR}" ]]; then
  echo "Unable to locate Callico sources in ${CALLICO_DIR}." >&2
  echo "Please ensure the repository keeps the callico directory alongside install/." >&2
  exit 1
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "docker is required but not installed." >&2
  exit 1
fi

if ! docker compose version >/dev/null 2>&1; then
  echo "docker compose v2 is required but was not found." >&2
  exit 1
fi

if [[ ! -f "${ENV_FILE}" ]]; then
  if ! create_env_file; then
    if [[ -f "${ENV_EXAMPLE}" ]]; then
      cp "${ENV_EXAMPLE}" "${ENV_FILE}" \
        && echo "A template has been copied to ${ENV_FILE}." >&2
    fi
    cat >&2 <<'MSG'
Missing production environment file.
Please review it, adjust the secrets/domains and re-run this script.
MSG
    exit 1
  fi
fi

if [[ ! -s "${ENV_FILE}" ]]; then
  echo "${ENV_FILE} exists but is empty. Please configure it before continuing." >&2
  exit 1
fi

set -a
source "${ENV_FILE}"
set +a

export CALLICO_ENV_FILE="${CALLICO_ENV_FILE:-${ENV_FILE}}"

CERTS_DIR_RELATIVE="${TRAEFIK_CERTS_DIR:-./traefik/certs}"
if [[ "${CERTS_DIR_RELATIVE}" = /* ]]; then
  CERTS_DIR="${CERTS_DIR_RELATIVE}"
else
  CERTS_DIR="${CALLICO_DIR}/${CERTS_DIR_RELATIVE#./}"
fi
mkdir -p "${CERTS_DIR}"

ACME_FILE="${CERTS_DIR}/acme.json"
if [[ ! -f "${ACME_FILE}" ]]; then
  touch "${ACME_FILE}"
fi
chmod 600 "${ACME_FILE}"

TLS_CONFIG_RELATIVE="${TRAEFIK_TLS_CONFIG_FILE:-./traefik/certs/tls.toml}"
if [[ "${TLS_CONFIG_RELATIVE}" = /* ]]; then
  TLS_CONFIG_FILE="${TLS_CONFIG_RELATIVE}"
else
  TLS_CONFIG_FILE="${CALLICO_DIR}/${TLS_CONFIG_RELATIVE#./}"
fi
mkdir -p "$(dirname "${TLS_CONFIG_FILE}")"

write_tls_config() {
  if [[ -n "${TRAEFIK_TLS_CERT_FILE:-}" || -n "${TRAEFIK_TLS_KEY_FILE:-}" ]]; then
    if [[ -z "${TRAEFIK_TLS_CERT_FILE:-}" || -z "${TRAEFIK_TLS_KEY_FILE:-}" ]]; then
      echo "Both TRAEFIK_TLS_CERT_FILE and TRAEFIK_TLS_KEY_FILE must be set to configure a custom certificate." >&2
      exit 1
    fi

    local cert_path key_path cert_mount key_mount
    if [[ "${TRAEFIK_TLS_CERT_FILE}" = /* ]]; then
      cert_path="${TRAEFIK_TLS_CERT_FILE}"
      cert_mount="$(basename "${TRAEFIK_TLS_CERT_FILE}")"
    else
      cert_path="${CERTS_DIR}/${TRAEFIK_TLS_CERT_FILE}"
      cert_mount="${TRAEFIK_TLS_CERT_FILE}"
    fi

    if [[ "${TRAEFIK_TLS_KEY_FILE}" = /* ]]; then
      key_path="${TRAEFIK_TLS_KEY_FILE}"
      key_mount="$(basename "${TRAEFIK_TLS_KEY_FILE}")"
    else
      key_path="${CERTS_DIR}/${TRAEFIK_TLS_KEY_FILE}"
      key_mount="${TRAEFIK_TLS_KEY_FILE}"
    fi

    if [[ ! -f "${cert_path}" ]]; then
      echo "Unable to find TLS certificate at ${cert_path}." >&2
      exit 1
    fi

    if [[ ! -f "${key_path}" ]]; then
      echo "Unable to find TLS private key at ${key_path}." >&2
      exit 1
    fi

    if [[ "${cert_path}" != "${CERTS_DIR}/${cert_mount}" ]]; then
      cp "${cert_path}" "${CERTS_DIR}/${cert_mount}"
      cert_path="${CERTS_DIR}/${cert_mount}"
    fi

    if [[ "${key_path}" != "${CERTS_DIR}/${key_mount}" ]]; then
      cp "${key_path}" "${CERTS_DIR}/${key_mount}"
      key_path="${CERTS_DIR}/${key_mount}"
    fi

    chmod 600 "${CERTS_DIR}/${cert_mount}" "${CERTS_DIR}/${key_mount}"

    cat >"${TLS_CONFIG_FILE}" <<EOF
[tls]
  [[tls.certificates]]
    certFile = "/certs/${cert_mount}"
    keyFile = "/certs/${key_mount}"
EOF
  else
    cat >"${TLS_CONFIG_FILE}" <<'EOF'
# No custom TLS certificate configured. Traefik will rely on ACME.
EOF
  fi
}

write_tls_config

if [[ -z "${TRAEFIK_TLS_CERT_FILE:-}" && -z "${TRAEFIK_TLS_KEY_FILE:-}" ]]; then
  if [[ -z "${TRAEFIK_ACME_EMAIL:-}" ]] && ! is_local_domain "${CALLICO_DOMAIN:-}"; then
    cat >&2 <<'MSG'
No custom TLS certificate has been provided and TRAEFIK_ACME_EMAIL is empty.
Traefik cannot request Let's Encrypt certificates without a contact e-mail. Set
TRAEFIK_ACME_EMAIL in install/production.env or provide certificate files.
MSG
    exit 1
  fi
fi

if [[ -z "${DJANGO_SUPERUSER_PASSWORD:-}" ]]; then
  echo "DJANGO_SUPERUSER_PASSWORD must be set in ${ENV_FILE}." >&2
  exit 1
fi

echo "Starting Callico stack..."
docker compose "${COMPOSE_ARGS[@]}" up -d

wait_for_postgres() {
  local retries=${1:-30}
  local delay=${2:-2}
  local pg_user="${POSTGRES_USER:-callico}"
  local pg_db="${POSTGRES_DB:-callico}"

  echo "Waiting for PostgreSQL to be ready..."
  for ((attempt = 1; attempt <= retries; attempt++)); do
    if docker compose "${COMPOSE_ARGS[@]}" exec -T postgres pg_isready -U "${pg_user}" -d "${pg_db}" >/dev/null 2>&1; then
      echo "PostgreSQL is ready."
      return 0
    fi
    sleep "${delay}"
  done

  echo "PostgreSQL did not become ready in time." >&2
  return 1
}

wait_for_postgres

echo "Running database migrations..."
docker compose "${COMPOSE_ARGS[@]}" run --rm callico django-admin migrate

echo "Collecting static files..."
docker compose "${COMPOSE_ARGS[@]}" run --rm callico django-admin collectstatic --noinput

echo "Creating Django superuser (will be skipped if it already exists)..."
if ! docker compose "${COMPOSE_ARGS[@]}" run --rm \
  -e DJANGO_SUPERUSER_USERNAME \
  -e DJANGO_SUPERUSER_EMAIL \
  -e DJANGO_SUPERUSER_PASSWORD \
  -e DJANGO_SUPERUSER_FIRST_NAME \
  -e DJANGO_SUPERUSER_LAST_NAME \
  -e DJANGO_SUPERUSER_DISPLAY_NAME \
  callico django-admin createsuperuser --noinput --display_name "${DJANGO_SUPERUSER_DISPLAY_NAME}"
then
  echo "Superuser creation skipped (probably already exists)." >&2
fi

echo "Callico is now running at ${INSTANCE_URL:-https://callico.example.com}."
